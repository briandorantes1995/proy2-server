# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[None, float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
            },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
            },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
            },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
            },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Usuario types

class UsuarioOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Usuario create method"""
    id: _int
    hospedado: _bool
    cuarto: 'habitacionesCreateNestedWithoutRelationsInput'
    habitacionesId: Optional[_int]


class UsuarioCreateInput(UsuarioOptionalCreateInput):
    """Required arguments to the Usuario create method"""
    nombre: _str
    email: _str
    password: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UsuarioOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Usuario create method, without relations"""
    id: _int
    hospedado: _bool
    habitacionesId: Optional[_int]


class UsuarioCreateWithoutRelationsInput(UsuarioOptionalCreateWithoutRelationsInput):
    """Required arguments to the Usuario create method, without relations"""
    nombre: _str
    email: _str
    password: _str


class UsuarioCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UsuarioCreateWithoutRelationsInput'
    connect: 'UsuarioWhereUniqueInput'


class UsuarioCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UsuarioCreateWithoutRelationsInput', List['UsuarioCreateWithoutRelationsInput']]
    connect: Union['UsuarioWhereUniqueInput', List['UsuarioWhereUniqueInput']]


_UsuarioWhereUnique_id_Input = TypedDict(
    '_UsuarioWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UsuarioWhereUnique_email_Input = TypedDict(
    '_UsuarioWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_UsuarioWhereUnique_habitacionesId_Input = TypedDict(
    '_UsuarioWhereUnique_habitacionesId_Input',
    {
        'habitacionesId': '_int',
    },
    total=True
)

UsuarioWhereUniqueInput = Union[
    '_UsuarioWhereUnique_id_Input',
    '_UsuarioWhereUnique_email_Input',
    '_UsuarioWhereUnique_habitacionesId_Input',
]


class UsuarioUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    nombre: _str
    email: _str
    password: _str
    hospedado: _bool
    cuarto: 'habitacionesUpdateOneWithoutRelationsInput'


class UsuarioUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    nombre: _str
    email: _str
    password: _str
    hospedado: _bool


class UsuarioUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UsuarioCreateWithoutRelationsInput']
    connect: List['UsuarioWhereUniqueInput']
    set: List['UsuarioWhereUniqueInput']
    disconnect: List['UsuarioWhereUniqueInput']
    delete: List['UsuarioWhereUniqueInput']

    # TODO
    # update: List['UsuarioUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UsuarioUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UsuarioScalarWhereInput']
    # upsert: List['UsuarioUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UsuarioCreateOrConnectWithoutRelationsInput']


class UsuarioUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UsuarioCreateWithoutRelationsInput'
    connect: 'UsuarioWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UsuarioUpdateInput'
    # upsert: 'UsuarioUpsertWithoutRelationsInput'
    # connectOrCreate: 'UsuarioCreateOrConnectWithoutRelationsInput'


class UsuarioUpsertInput(TypedDict):
    create: 'UsuarioCreateInput'
    update: 'UsuarioUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Usuario_id_OrderByInput = TypedDict(
    '_Usuario_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Usuario_nombre_OrderByInput = TypedDict(
    '_Usuario_nombre_OrderByInput',
    {
        'nombre': 'SortOrder',
    },
    total=True
)

_Usuario_email_OrderByInput = TypedDict(
    '_Usuario_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Usuario_password_OrderByInput = TypedDict(
    '_Usuario_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_Usuario_hospedado_OrderByInput = TypedDict(
    '_Usuario_hospedado_OrderByInput',
    {
        'hospedado': 'SortOrder',
    },
    total=True
)

_Usuario_habitacionesId_OrderByInput = TypedDict(
    '_Usuario_habitacionesId_OrderByInput',
    {
        'habitacionesId': 'SortOrder',
    },
    total=True
)

UsuarioOrderByInput = Union[
    '_Usuario_id_OrderByInput',
    '_Usuario_nombre_OrderByInput',
    '_Usuario_email_OrderByInput',
    '_Usuario_password_OrderByInput',
    '_Usuario_hospedado_OrderByInput',
    '_Usuario_habitacionesId_OrderByInput',
]



# recursive Usuario types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UsuarioRelationFilter = TypedDict(
    'UsuarioRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UsuarioListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UsuarioInclude(TypedDict, total=False):
    """Usuario relational arguments"""
    cuarto: Union[bool, 'habitacionesArgsFromUsuario']


    

class UsuarioIncludeFromUsuario(TypedDict, total=False):
    """Relational arguments for Usuario"""
    cuarto: Union[bool, 'habitacionesArgsFromUsuarioRecursive1']


class UsuarioIncludeFromUsuarioRecursive1(TypedDict, total=False):
    """Relational arguments for Usuario"""
    cuarto: Union[bool, 'habitacionesArgsFromUsuarioRecursive2']


class UsuarioIncludeFromUsuarioRecursive2(TypedDict, total=False):
    """Relational arguments for Usuario"""
    cuarto: Union[bool, 'habitacionesArgsFromUsuarioRecursive3']


class UsuarioIncludeFromUsuarioRecursive3(TypedDict, total=False):
    """Relational arguments for Usuario"""
    cuarto: Union[bool, 'habitacionesArgsFromUsuarioRecursive4']


class UsuarioIncludeFromUsuarioRecursive4(TypedDict, total=False):
    """Relational arguments for Usuario"""

    

class UsuarioArgsFromUsuario(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'UsuarioIncludeFromUsuarioRecursive1'


class UsuarioArgsFromUsuarioRecursive1(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'UsuarioIncludeFromUsuarioRecursive2'


class UsuarioArgsFromUsuarioRecursive2(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'UsuarioIncludeFromUsuarioRecursive3'


class UsuarioArgsFromUsuarioRecursive3(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'UsuarioIncludeFromUsuarioRecursive4'


class UsuarioArgsFromUsuarioRecursive4(TypedDict, total=False):
    """Arguments for Usuario"""
    
    

class FindManyUsuarioArgsFromUsuario(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive1'


class FindManyUsuarioArgsFromUsuarioRecursive1(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive2'


class FindManyUsuarioArgsFromUsuarioRecursive2(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive3'


class FindManyUsuarioArgsFromUsuarioRecursive3(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive4'


class FindManyUsuarioArgsFromUsuarioRecursive4(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    
    

class EmpleadoIncludeFromUsuario(TypedDict, total=False):
    """Relational arguments for Usuario"""


class EmpleadoIncludeFromUsuarioRecursive1(TypedDict, total=False):
    """Relational arguments for Usuario"""


class EmpleadoIncludeFromUsuarioRecursive2(TypedDict, total=False):
    """Relational arguments for Usuario"""


class EmpleadoIncludeFromUsuarioRecursive3(TypedDict, total=False):
    """Relational arguments for Usuario"""


class EmpleadoIncludeFromUsuarioRecursive4(TypedDict, total=False):
    """Relational arguments for Usuario"""

    

class EmpleadoArgsFromUsuario(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive1'


class EmpleadoArgsFromUsuarioRecursive1(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive2'


class EmpleadoArgsFromUsuarioRecursive2(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive3'


class EmpleadoArgsFromUsuarioRecursive3(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive4'


class EmpleadoArgsFromUsuarioRecursive4(TypedDict, total=False):
    """Arguments for Usuario"""
    
    

class FindManyEmpleadoArgsFromUsuario(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive1'


class FindManyEmpleadoArgsFromUsuarioRecursive1(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive2'


class FindManyEmpleadoArgsFromUsuarioRecursive2(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive3'


class FindManyEmpleadoArgsFromUsuarioRecursive3(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive4'


class FindManyEmpleadoArgsFromUsuarioRecursive4(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    
    

class tipohabitacionIncludeFromUsuario(TypedDict, total=False):
    """Relational arguments for Usuario"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromUsuarioRecursive1']


class tipohabitacionIncludeFromUsuarioRecursive1(TypedDict, total=False):
    """Relational arguments for Usuario"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromUsuarioRecursive2']


class tipohabitacionIncludeFromUsuarioRecursive2(TypedDict, total=False):
    """Relational arguments for Usuario"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromUsuarioRecursive3']


class tipohabitacionIncludeFromUsuarioRecursive3(TypedDict, total=False):
    """Relational arguments for Usuario"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromUsuarioRecursive4']


class tipohabitacionIncludeFromUsuarioRecursive4(TypedDict, total=False):
    """Relational arguments for Usuario"""

    

class tipohabitacionArgsFromUsuario(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive1'


class tipohabitacionArgsFromUsuarioRecursive1(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive2'


class tipohabitacionArgsFromUsuarioRecursive2(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive3'


class tipohabitacionArgsFromUsuarioRecursive3(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive4'


class tipohabitacionArgsFromUsuarioRecursive4(TypedDict, total=False):
    """Arguments for Usuario"""
    
    

class FindManytipohabitacionArgsFromUsuario(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive1'


class FindManytipohabitacionArgsFromUsuarioRecursive1(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive2'


class FindManytipohabitacionArgsFromUsuarioRecursive2(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive3'


class FindManytipohabitacionArgsFromUsuarioRecursive3(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive4'


class FindManytipohabitacionArgsFromUsuarioRecursive4(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    
    

class habitacionesIncludeFromUsuario(TypedDict, total=False):
    """Relational arguments for Usuario"""
    Usuario: Union[bool, 'UsuarioArgsFromUsuarioRecursive1']
    tipo: Union[bool, 'tipohabitacionArgsFromUsuarioRecursive1']


class habitacionesIncludeFromUsuarioRecursive1(TypedDict, total=False):
    """Relational arguments for Usuario"""
    Usuario: Union[bool, 'UsuarioArgsFromUsuarioRecursive2']
    tipo: Union[bool, 'tipohabitacionArgsFromUsuarioRecursive2']


class habitacionesIncludeFromUsuarioRecursive2(TypedDict, total=False):
    """Relational arguments for Usuario"""
    Usuario: Union[bool, 'UsuarioArgsFromUsuarioRecursive3']
    tipo: Union[bool, 'tipohabitacionArgsFromUsuarioRecursive3']


class habitacionesIncludeFromUsuarioRecursive3(TypedDict, total=False):
    """Relational arguments for Usuario"""
    Usuario: Union[bool, 'UsuarioArgsFromUsuarioRecursive4']
    tipo: Union[bool, 'tipohabitacionArgsFromUsuarioRecursive4']


class habitacionesIncludeFromUsuarioRecursive4(TypedDict, total=False):
    """Relational arguments for Usuario"""

    

class habitacionesArgsFromUsuario(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'habitacionesIncludeFromhabitacionesRecursive1'


class habitacionesArgsFromUsuarioRecursive1(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'habitacionesIncludeFromhabitacionesRecursive2'


class habitacionesArgsFromUsuarioRecursive2(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'habitacionesIncludeFromhabitacionesRecursive3'


class habitacionesArgsFromUsuarioRecursive3(TypedDict, total=False):
    """Arguments for Usuario"""
    include: 'habitacionesIncludeFromhabitacionesRecursive4'


class habitacionesArgsFromUsuarioRecursive4(TypedDict, total=False):
    """Arguments for Usuario"""
    
    

class FindManyhabitacionesArgsFromUsuario(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive1'


class FindManyhabitacionesArgsFromUsuarioRecursive1(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive2'


class FindManyhabitacionesArgsFromUsuarioRecursive2(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive3'


class FindManyhabitacionesArgsFromUsuarioRecursive3(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive4'


class FindManyhabitacionesArgsFromUsuarioRecursive4(TypedDict, total=False):
    """Arguments for Usuario"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    


FindManyUsuarioArgs = FindManyUsuarioArgsFromUsuario
FindFirstUsuarioArgs = FindManyUsuarioArgsFromUsuario


    

class UsuarioWhereInput(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    hospedado: Union[_bool, 'types.BooleanFilter']
    cuarto: 'habitacionesRelationFilter'
    habitacionesId: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['UsuarioWhereInputRecursive1', List['UsuarioWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UsuarioWhereInputRecursive1']
    OR: List['UsuarioWhereInputRecursive1']
    NOT: List['UsuarioWhereInputRecursive1']


class UsuarioWhereInputRecursive1(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    hospedado: Union[_bool, 'types.BooleanFilter']
    cuarto: 'habitacionesRelationFilter'
    habitacionesId: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['UsuarioWhereInputRecursive2', List['UsuarioWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UsuarioWhereInputRecursive2']
    OR: List['UsuarioWhereInputRecursive2']
    NOT: List['UsuarioWhereInputRecursive2']


class UsuarioWhereInputRecursive2(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    hospedado: Union[_bool, 'types.BooleanFilter']
    cuarto: 'habitacionesRelationFilter'
    habitacionesId: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['UsuarioWhereInputRecursive3', List['UsuarioWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UsuarioWhereInputRecursive3']
    OR: List['UsuarioWhereInputRecursive3']
    NOT: List['UsuarioWhereInputRecursive3']


class UsuarioWhereInputRecursive3(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    hospedado: Union[_bool, 'types.BooleanFilter']
    cuarto: 'habitacionesRelationFilter'
    habitacionesId: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['UsuarioWhereInputRecursive4', List['UsuarioWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UsuarioWhereInputRecursive4']
    OR: List['UsuarioWhereInputRecursive4']
    NOT: List['UsuarioWhereInputRecursive4']


class UsuarioWhereInputRecursive4(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    hospedado: Union[_bool, 'types.BooleanFilter']
    cuarto: 'habitacionesRelationFilter'
    habitacionesId: Union[None, _int, 'types.IntFilter']



# aggregate Usuario types


    

class UsuarioScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    hospedado: Union[_bool, 'types.BooleanWithAggregatesFilter']
    habitacionesId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UsuarioScalarWhereWithAggregatesInputRecursive1']
    OR: List['UsuarioScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UsuarioScalarWhereWithAggregatesInputRecursive1']


class UsuarioScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    hospedado: Union[_bool, 'types.BooleanWithAggregatesFilter']
    habitacionesId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UsuarioScalarWhereWithAggregatesInputRecursive2']
    OR: List['UsuarioScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UsuarioScalarWhereWithAggregatesInputRecursive2']


class UsuarioScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    hospedado: Union[_bool, 'types.BooleanWithAggregatesFilter']
    habitacionesId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UsuarioScalarWhereWithAggregatesInputRecursive3']
    OR: List['UsuarioScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UsuarioScalarWhereWithAggregatesInputRecursive3']


class UsuarioScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    hospedado: Union[_bool, 'types.BooleanWithAggregatesFilter']
    habitacionesId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UsuarioScalarWhereWithAggregatesInputRecursive4']
    OR: List['UsuarioScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UsuarioScalarWhereWithAggregatesInputRecursive4']


class UsuarioScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Usuario arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    hospedado: Union[_bool, 'types.BooleanWithAggregatesFilter']
    habitacionesId: Union[_int, 'types.IntWithAggregatesFilter']



class UsuarioGroupByOutput(TypedDict, total=False):
    id: _int
    nombre: _str
    email: _str
    password: _str
    hospedado: _bool
    habitacionesId: _int
    _sum: 'UsuarioSumAggregateOutput'
    _avg: 'UsuarioAvgAggregateOutput'
    _min: 'UsuarioMinAggregateOutput'
    _max: 'UsuarioMaxAggregateOutput'
    _count: 'UsuarioCountAggregateOutput'


class UsuarioAvgAggregateOutput(TypedDict, total=False):
    """Usuario output for aggregating averages"""
    id: float
    habitacionesId: float


class UsuarioSumAggregateOutput(TypedDict, total=False):
    """Usuario output for aggregating sums"""
    id: _int
    habitacionesId: _int


class UsuarioScalarAggregateOutput(TypedDict, total=False):
    """Usuario output including scalar fields"""
    id: _int
    nombre: _str
    email: _str
    password: _str
    hospedado: _bool
    habitacionesId: _int


UsuarioMinAggregateOutput = UsuarioScalarAggregateOutput
UsuarioMaxAggregateOutput = UsuarioScalarAggregateOutput


class UsuarioMaxAggregateInput(TypedDict, total=False):
    """Usuario input for aggregating by max"""
    id: bool
    nombre: bool
    email: bool
    password: bool
    hospedado: bool
    habitacionesId: bool


class UsuarioMinAggregateInput(TypedDict, total=False):
    """Usuario input for aggregating by min"""
    id: bool
    nombre: bool
    email: bool
    password: bool
    hospedado: bool
    habitacionesId: bool


class UsuarioNumberAggregateInput(TypedDict, total=False):
    """Usuario input for aggregating numbers"""
    id: bool
    habitacionesId: bool


UsuarioAvgAggregateInput = UsuarioNumberAggregateInput
UsuarioSumAggregateInput = UsuarioNumberAggregateInput


UsuarioCountAggregateInput = TypedDict(
    'UsuarioCountAggregateInput',
    {
        'id': bool,
        'nombre': bool,
        'email': bool,
        'password': bool,
        'hospedado': bool,
        'habitacionesId': bool,
        '_all': bool,
    },
    total=False,
)

UsuarioCountAggregateOutput = TypedDict(
    'UsuarioCountAggregateOutput',
    {
        'id': int,
        'nombre': int,
        'email': int,
        'password': int,
        'hospedado': int,
        'habitacionesId': int,
        '_all': int,
    },
    total=False,
)


UsuarioKeys = Literal[
    'id',
    'nombre',
    'email',
    'password',
    'hospedado',
    'cuarto',
    'habitacionesId',
]
UsuarioScalarFieldKeys = Literal[
    'id',
    'nombre',
    'email',
    'password',
    'hospedado',
    'habitacionesId',
]
UsuarioScalarFieldKeysT = TypeVar('UsuarioScalarFieldKeysT', bound=UsuarioScalarFieldKeys)

UsuarioRelationalFieldKeys = Literal[
        'cuarto',
    ]

# Empleado types

class EmpleadoOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Empleado create method"""
    id: _int
    nombre: Optional[_str]
    rol: _str


class EmpleadoCreateInput(EmpleadoOptionalCreateInput):
    """Required arguments to the Empleado create method"""
    email: _str
    password: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class EmpleadoOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Empleado create method, without relations"""
    id: _int
    nombre: Optional[_str]
    rol: _str


class EmpleadoCreateWithoutRelationsInput(EmpleadoOptionalCreateWithoutRelationsInput):
    """Required arguments to the Empleado create method, without relations"""
    email: _str
    password: _str


class EmpleadoCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'EmpleadoCreateWithoutRelationsInput'
    connect: 'EmpleadoWhereUniqueInput'


class EmpleadoCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['EmpleadoCreateWithoutRelationsInput', List['EmpleadoCreateWithoutRelationsInput']]
    connect: Union['EmpleadoWhereUniqueInput', List['EmpleadoWhereUniqueInput']]


_EmpleadoWhereUnique_id_Input = TypedDict(
    '_EmpleadoWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_EmpleadoWhereUnique_email_Input = TypedDict(
    '_EmpleadoWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

EmpleadoWhereUniqueInput = Union[
    '_EmpleadoWhereUnique_id_Input',
    '_EmpleadoWhereUnique_email_Input',
]


class EmpleadoUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    nombre: Optional[_str]
    email: _str
    password: _str
    rol: _str


class EmpleadoUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    nombre: Optional[_str]
    email: _str
    password: _str
    rol: _str


class EmpleadoUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['EmpleadoCreateWithoutRelationsInput']
    connect: List['EmpleadoWhereUniqueInput']
    set: List['EmpleadoWhereUniqueInput']
    disconnect: List['EmpleadoWhereUniqueInput']
    delete: List['EmpleadoWhereUniqueInput']

    # TODO
    # update: List['EmpleadoUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['EmpleadoUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['EmpleadoScalarWhereInput']
    # upsert: List['EmpleadoUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['EmpleadoCreateOrConnectWithoutRelationsInput']


class EmpleadoUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'EmpleadoCreateWithoutRelationsInput'
    connect: 'EmpleadoWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'EmpleadoUpdateInput'
    # upsert: 'EmpleadoUpsertWithoutRelationsInput'
    # connectOrCreate: 'EmpleadoCreateOrConnectWithoutRelationsInput'


class EmpleadoUpsertInput(TypedDict):
    create: 'EmpleadoCreateInput'
    update: 'EmpleadoUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Empleado_id_OrderByInput = TypedDict(
    '_Empleado_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Empleado_nombre_OrderByInput = TypedDict(
    '_Empleado_nombre_OrderByInput',
    {
        'nombre': 'SortOrder',
    },
    total=True
)

_Empleado_email_OrderByInput = TypedDict(
    '_Empleado_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Empleado_password_OrderByInput = TypedDict(
    '_Empleado_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_Empleado_rol_OrderByInput = TypedDict(
    '_Empleado_rol_OrderByInput',
    {
        'rol': 'SortOrder',
    },
    total=True
)

EmpleadoOrderByInput = Union[
    '_Empleado_id_OrderByInput',
    '_Empleado_nombre_OrderByInput',
    '_Empleado_email_OrderByInput',
    '_Empleado_password_OrderByInput',
    '_Empleado_rol_OrderByInput',
]



# recursive Empleado types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

EmpleadoRelationFilter = TypedDict(
    'EmpleadoRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class EmpleadoListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class EmpleadoInclude(TypedDict, total=False):
    """Empleado relational arguments"""


    

class UsuarioIncludeFromEmpleado(TypedDict, total=False):
    """Relational arguments for Empleado"""
    cuarto: Union[bool, 'habitacionesArgsFromEmpleadoRecursive1']


class UsuarioIncludeFromEmpleadoRecursive1(TypedDict, total=False):
    """Relational arguments for Empleado"""
    cuarto: Union[bool, 'habitacionesArgsFromEmpleadoRecursive2']


class UsuarioIncludeFromEmpleadoRecursive2(TypedDict, total=False):
    """Relational arguments for Empleado"""
    cuarto: Union[bool, 'habitacionesArgsFromEmpleadoRecursive3']


class UsuarioIncludeFromEmpleadoRecursive3(TypedDict, total=False):
    """Relational arguments for Empleado"""
    cuarto: Union[bool, 'habitacionesArgsFromEmpleadoRecursive4']


class UsuarioIncludeFromEmpleadoRecursive4(TypedDict, total=False):
    """Relational arguments for Empleado"""

    

class UsuarioArgsFromEmpleado(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'UsuarioIncludeFromUsuarioRecursive1'


class UsuarioArgsFromEmpleadoRecursive1(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'UsuarioIncludeFromUsuarioRecursive2'


class UsuarioArgsFromEmpleadoRecursive2(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'UsuarioIncludeFromUsuarioRecursive3'


class UsuarioArgsFromEmpleadoRecursive3(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'UsuarioIncludeFromUsuarioRecursive4'


class UsuarioArgsFromEmpleadoRecursive4(TypedDict, total=False):
    """Arguments for Empleado"""
    
    

class FindManyUsuarioArgsFromEmpleado(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive1'


class FindManyUsuarioArgsFromEmpleadoRecursive1(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive2'


class FindManyUsuarioArgsFromEmpleadoRecursive2(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive3'


class FindManyUsuarioArgsFromEmpleadoRecursive3(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive4'


class FindManyUsuarioArgsFromEmpleadoRecursive4(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    
    

class EmpleadoIncludeFromEmpleado(TypedDict, total=False):
    """Relational arguments for Empleado"""


class EmpleadoIncludeFromEmpleadoRecursive1(TypedDict, total=False):
    """Relational arguments for Empleado"""


class EmpleadoIncludeFromEmpleadoRecursive2(TypedDict, total=False):
    """Relational arguments for Empleado"""


class EmpleadoIncludeFromEmpleadoRecursive3(TypedDict, total=False):
    """Relational arguments for Empleado"""


class EmpleadoIncludeFromEmpleadoRecursive4(TypedDict, total=False):
    """Relational arguments for Empleado"""

    

class EmpleadoArgsFromEmpleado(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive1'


class EmpleadoArgsFromEmpleadoRecursive1(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive2'


class EmpleadoArgsFromEmpleadoRecursive2(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive3'


class EmpleadoArgsFromEmpleadoRecursive3(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive4'


class EmpleadoArgsFromEmpleadoRecursive4(TypedDict, total=False):
    """Arguments for Empleado"""
    
    

class FindManyEmpleadoArgsFromEmpleado(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive1'


class FindManyEmpleadoArgsFromEmpleadoRecursive1(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive2'


class FindManyEmpleadoArgsFromEmpleadoRecursive2(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive3'


class FindManyEmpleadoArgsFromEmpleadoRecursive3(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive4'


class FindManyEmpleadoArgsFromEmpleadoRecursive4(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    
    

class tipohabitacionIncludeFromEmpleado(TypedDict, total=False):
    """Relational arguments for Empleado"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromEmpleadoRecursive1']


class tipohabitacionIncludeFromEmpleadoRecursive1(TypedDict, total=False):
    """Relational arguments for Empleado"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromEmpleadoRecursive2']


class tipohabitacionIncludeFromEmpleadoRecursive2(TypedDict, total=False):
    """Relational arguments for Empleado"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromEmpleadoRecursive3']


class tipohabitacionIncludeFromEmpleadoRecursive3(TypedDict, total=False):
    """Relational arguments for Empleado"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromEmpleadoRecursive4']


class tipohabitacionIncludeFromEmpleadoRecursive4(TypedDict, total=False):
    """Relational arguments for Empleado"""

    

class tipohabitacionArgsFromEmpleado(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive1'


class tipohabitacionArgsFromEmpleadoRecursive1(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive2'


class tipohabitacionArgsFromEmpleadoRecursive2(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive3'


class tipohabitacionArgsFromEmpleadoRecursive3(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive4'


class tipohabitacionArgsFromEmpleadoRecursive4(TypedDict, total=False):
    """Arguments for Empleado"""
    
    

class FindManytipohabitacionArgsFromEmpleado(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive1'


class FindManytipohabitacionArgsFromEmpleadoRecursive1(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive2'


class FindManytipohabitacionArgsFromEmpleadoRecursive2(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive3'


class FindManytipohabitacionArgsFromEmpleadoRecursive3(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive4'


class FindManytipohabitacionArgsFromEmpleadoRecursive4(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    
    

class habitacionesIncludeFromEmpleado(TypedDict, total=False):
    """Relational arguments for Empleado"""
    Usuario: Union[bool, 'UsuarioArgsFromEmpleadoRecursive1']
    tipo: Union[bool, 'tipohabitacionArgsFromEmpleadoRecursive1']


class habitacionesIncludeFromEmpleadoRecursive1(TypedDict, total=False):
    """Relational arguments for Empleado"""
    Usuario: Union[bool, 'UsuarioArgsFromEmpleadoRecursive2']
    tipo: Union[bool, 'tipohabitacionArgsFromEmpleadoRecursive2']


class habitacionesIncludeFromEmpleadoRecursive2(TypedDict, total=False):
    """Relational arguments for Empleado"""
    Usuario: Union[bool, 'UsuarioArgsFromEmpleadoRecursive3']
    tipo: Union[bool, 'tipohabitacionArgsFromEmpleadoRecursive3']


class habitacionesIncludeFromEmpleadoRecursive3(TypedDict, total=False):
    """Relational arguments for Empleado"""
    Usuario: Union[bool, 'UsuarioArgsFromEmpleadoRecursive4']
    tipo: Union[bool, 'tipohabitacionArgsFromEmpleadoRecursive4']


class habitacionesIncludeFromEmpleadoRecursive4(TypedDict, total=False):
    """Relational arguments for Empleado"""

    

class habitacionesArgsFromEmpleado(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'habitacionesIncludeFromhabitacionesRecursive1'


class habitacionesArgsFromEmpleadoRecursive1(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'habitacionesIncludeFromhabitacionesRecursive2'


class habitacionesArgsFromEmpleadoRecursive2(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'habitacionesIncludeFromhabitacionesRecursive3'


class habitacionesArgsFromEmpleadoRecursive3(TypedDict, total=False):
    """Arguments for Empleado"""
    include: 'habitacionesIncludeFromhabitacionesRecursive4'


class habitacionesArgsFromEmpleadoRecursive4(TypedDict, total=False):
    """Arguments for Empleado"""
    
    

class FindManyhabitacionesArgsFromEmpleado(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive1'


class FindManyhabitacionesArgsFromEmpleadoRecursive1(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive2'


class FindManyhabitacionesArgsFromEmpleadoRecursive2(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive3'


class FindManyhabitacionesArgsFromEmpleadoRecursive3(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive4'


class FindManyhabitacionesArgsFromEmpleadoRecursive4(TypedDict, total=False):
    """Arguments for Empleado"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    


FindManyEmpleadoArgs = FindManyEmpleadoArgsFromEmpleado
FindFirstEmpleadoArgs = FindManyEmpleadoArgsFromEmpleado


    

class EmpleadoWhereInput(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    rol: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['EmpleadoWhereInputRecursive1', List['EmpleadoWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['EmpleadoWhereInputRecursive1']
    OR: List['EmpleadoWhereInputRecursive1']
    NOT: List['EmpleadoWhereInputRecursive1']


class EmpleadoWhereInputRecursive1(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    rol: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['EmpleadoWhereInputRecursive2', List['EmpleadoWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['EmpleadoWhereInputRecursive2']
    OR: List['EmpleadoWhereInputRecursive2']
    NOT: List['EmpleadoWhereInputRecursive2']


class EmpleadoWhereInputRecursive2(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    rol: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['EmpleadoWhereInputRecursive3', List['EmpleadoWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['EmpleadoWhereInputRecursive3']
    OR: List['EmpleadoWhereInputRecursive3']
    NOT: List['EmpleadoWhereInputRecursive3']


class EmpleadoWhereInputRecursive3(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    rol: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['EmpleadoWhereInputRecursive4', List['EmpleadoWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['EmpleadoWhereInputRecursive4']
    OR: List['EmpleadoWhereInputRecursive4']
    NOT: List['EmpleadoWhereInputRecursive4']


class EmpleadoWhereInputRecursive4(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    nombre: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    rol: Union[_str, 'types.StringFilter']



# aggregate Empleado types


    

class EmpleadoScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    rol: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['EmpleadoScalarWhereWithAggregatesInputRecursive1']
    OR: List['EmpleadoScalarWhereWithAggregatesInputRecursive1']
    NOT: List['EmpleadoScalarWhereWithAggregatesInputRecursive1']


class EmpleadoScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    rol: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['EmpleadoScalarWhereWithAggregatesInputRecursive2']
    OR: List['EmpleadoScalarWhereWithAggregatesInputRecursive2']
    NOT: List['EmpleadoScalarWhereWithAggregatesInputRecursive2']


class EmpleadoScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    rol: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['EmpleadoScalarWhereWithAggregatesInputRecursive3']
    OR: List['EmpleadoScalarWhereWithAggregatesInputRecursive3']
    NOT: List['EmpleadoScalarWhereWithAggregatesInputRecursive3']


class EmpleadoScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    rol: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['EmpleadoScalarWhereWithAggregatesInputRecursive4']
    OR: List['EmpleadoScalarWhereWithAggregatesInputRecursive4']
    NOT: List['EmpleadoScalarWhereWithAggregatesInputRecursive4']


class EmpleadoScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Empleado arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    nombre: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    rol: Union[_str, 'types.StringWithAggregatesFilter']



class EmpleadoGroupByOutput(TypedDict, total=False):
    id: _int
    nombre: _str
    email: _str
    password: _str
    rol: _str
    _sum: 'EmpleadoSumAggregateOutput'
    _avg: 'EmpleadoAvgAggregateOutput'
    _min: 'EmpleadoMinAggregateOutput'
    _max: 'EmpleadoMaxAggregateOutput'
    _count: 'EmpleadoCountAggregateOutput'


class EmpleadoAvgAggregateOutput(TypedDict, total=False):
    """Empleado output for aggregating averages"""
    id: float


class EmpleadoSumAggregateOutput(TypedDict, total=False):
    """Empleado output for aggregating sums"""
    id: _int


class EmpleadoScalarAggregateOutput(TypedDict, total=False):
    """Empleado output including scalar fields"""
    id: _int
    nombre: _str
    email: _str
    password: _str
    rol: _str


EmpleadoMinAggregateOutput = EmpleadoScalarAggregateOutput
EmpleadoMaxAggregateOutput = EmpleadoScalarAggregateOutput


class EmpleadoMaxAggregateInput(TypedDict, total=False):
    """Empleado input for aggregating by max"""
    id: bool
    nombre: bool
    email: bool
    password: bool
    rol: bool


class EmpleadoMinAggregateInput(TypedDict, total=False):
    """Empleado input for aggregating by min"""
    id: bool
    nombre: bool
    email: bool
    password: bool
    rol: bool


class EmpleadoNumberAggregateInput(TypedDict, total=False):
    """Empleado input for aggregating numbers"""
    id: bool


EmpleadoAvgAggregateInput = EmpleadoNumberAggregateInput
EmpleadoSumAggregateInput = EmpleadoNumberAggregateInput


EmpleadoCountAggregateInput = TypedDict(
    'EmpleadoCountAggregateInput',
    {
        'id': bool,
        'nombre': bool,
        'email': bool,
        'password': bool,
        'rol': bool,
        '_all': bool,
    },
    total=False,
)

EmpleadoCountAggregateOutput = TypedDict(
    'EmpleadoCountAggregateOutput',
    {
        'id': int,
        'nombre': int,
        'email': int,
        'password': int,
        'rol': int,
        '_all': int,
    },
    total=False,
)


EmpleadoKeys = Literal[
    'id',
    'nombre',
    'email',
    'password',
    'rol',
]
EmpleadoScalarFieldKeys = Literal[
    'id',
    'nombre',
    'email',
    'password',
    'rol',
]
EmpleadoScalarFieldKeysT = TypeVar('EmpleadoScalarFieldKeysT', bound=EmpleadoScalarFieldKeys)

EmpleadoRelationalFieldKeys = _NoneType

# tipohabitacion types

class tipohabitacionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the tipohabitacion create method"""
    id: _int
    tipo: Optional[_str]
    habitaciones: 'habitacionesCreateManyNestedWithoutRelationsInput'


class tipohabitacionCreateInput(tipohabitacionOptionalCreateInput):
    """Required arguments to the tipohabitacion create method"""
    descripcion: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class tipohabitacionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the tipohabitacion create method, without relations"""
    id: _int
    tipo: Optional[_str]


class tipohabitacionCreateWithoutRelationsInput(tipohabitacionOptionalCreateWithoutRelationsInput):
    """Required arguments to the tipohabitacion create method, without relations"""
    descripcion: _str


class tipohabitacionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'tipohabitacionCreateWithoutRelationsInput'
    connect: 'tipohabitacionWhereUniqueInput'


class tipohabitacionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['tipohabitacionCreateWithoutRelationsInput', List['tipohabitacionCreateWithoutRelationsInput']]
    connect: Union['tipohabitacionWhereUniqueInput', List['tipohabitacionWhereUniqueInput']]


_tipohabitacionWhereUnique_id_Input = TypedDict(
    '_tipohabitacionWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_tipohabitacionWhereUnique_tipo_Input = TypedDict(
    '_tipohabitacionWhereUnique_tipo_Input',
    {
        'tipo': '_str',
    },
    total=True
)

tipohabitacionWhereUniqueInput = Union[
    '_tipohabitacionWhereUnique_id_Input',
    '_tipohabitacionWhereUnique_tipo_Input',
]


class tipohabitacionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    tipo: Optional[_str]
    descripcion: _str
    habitaciones: 'habitacionesUpdateManyWithoutRelationsInput'


class tipohabitacionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    tipo: Optional[_str]
    descripcion: _str


class tipohabitacionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['tipohabitacionCreateWithoutRelationsInput']
    connect: List['tipohabitacionWhereUniqueInput']
    set: List['tipohabitacionWhereUniqueInput']
    disconnect: List['tipohabitacionWhereUniqueInput']
    delete: List['tipohabitacionWhereUniqueInput']

    # TODO
    # update: List['tipohabitacionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['tipohabitacionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['tipohabitacionScalarWhereInput']
    # upsert: List['tipohabitacionUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['tipohabitacionCreateOrConnectWithoutRelationsInput']


class tipohabitacionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'tipohabitacionCreateWithoutRelationsInput'
    connect: 'tipohabitacionWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'tipohabitacionUpdateInput'
    # upsert: 'tipohabitacionUpsertWithoutRelationsInput'
    # connectOrCreate: 'tipohabitacionCreateOrConnectWithoutRelationsInput'


class tipohabitacionUpsertInput(TypedDict):
    create: 'tipohabitacionCreateInput'
    update: 'tipohabitacionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_tipohabitacion_id_OrderByInput = TypedDict(
    '_tipohabitacion_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_tipohabitacion_tipo_OrderByInput = TypedDict(
    '_tipohabitacion_tipo_OrderByInput',
    {
        'tipo': 'SortOrder',
    },
    total=True
)

_tipohabitacion_descripcion_OrderByInput = TypedDict(
    '_tipohabitacion_descripcion_OrderByInput',
    {
        'descripcion': 'SortOrder',
    },
    total=True
)

tipohabitacionOrderByInput = Union[
    '_tipohabitacion_id_OrderByInput',
    '_tipohabitacion_tipo_OrderByInput',
    '_tipohabitacion_descripcion_OrderByInput',
]



# recursive tipohabitacion types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

tipohabitacionRelationFilter = TypedDict(
    'tipohabitacionRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class tipohabitacionListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class tipohabitacionInclude(TypedDict, total=False):
    """tipohabitacion relational arguments"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromtipohabitacion']


    

class UsuarioIncludeFromtipohabitacion(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    cuarto: Union[bool, 'habitacionesArgsFromtipohabitacionRecursive1']


class UsuarioIncludeFromtipohabitacionRecursive1(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    cuarto: Union[bool, 'habitacionesArgsFromtipohabitacionRecursive2']


class UsuarioIncludeFromtipohabitacionRecursive2(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    cuarto: Union[bool, 'habitacionesArgsFromtipohabitacionRecursive3']


class UsuarioIncludeFromtipohabitacionRecursive3(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    cuarto: Union[bool, 'habitacionesArgsFromtipohabitacionRecursive4']


class UsuarioIncludeFromtipohabitacionRecursive4(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""

    

class UsuarioArgsFromtipohabitacion(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'UsuarioIncludeFromUsuarioRecursive1'


class UsuarioArgsFromtipohabitacionRecursive1(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'UsuarioIncludeFromUsuarioRecursive2'


class UsuarioArgsFromtipohabitacionRecursive2(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'UsuarioIncludeFromUsuarioRecursive3'


class UsuarioArgsFromtipohabitacionRecursive3(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'UsuarioIncludeFromUsuarioRecursive4'


class UsuarioArgsFromtipohabitacionRecursive4(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    
    

class FindManyUsuarioArgsFromtipohabitacion(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive1'


class FindManyUsuarioArgsFromtipohabitacionRecursive1(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive2'


class FindManyUsuarioArgsFromtipohabitacionRecursive2(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive3'


class FindManyUsuarioArgsFromtipohabitacionRecursive3(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive4'


class FindManyUsuarioArgsFromtipohabitacionRecursive4(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    
    

class EmpleadoIncludeFromtipohabitacion(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""


class EmpleadoIncludeFromtipohabitacionRecursive1(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""


class EmpleadoIncludeFromtipohabitacionRecursive2(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""


class EmpleadoIncludeFromtipohabitacionRecursive3(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""


class EmpleadoIncludeFromtipohabitacionRecursive4(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""

    

class EmpleadoArgsFromtipohabitacion(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive1'


class EmpleadoArgsFromtipohabitacionRecursive1(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive2'


class EmpleadoArgsFromtipohabitacionRecursive2(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive3'


class EmpleadoArgsFromtipohabitacionRecursive3(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive4'


class EmpleadoArgsFromtipohabitacionRecursive4(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    
    

class FindManyEmpleadoArgsFromtipohabitacion(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive1'


class FindManyEmpleadoArgsFromtipohabitacionRecursive1(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive2'


class FindManyEmpleadoArgsFromtipohabitacionRecursive2(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive3'


class FindManyEmpleadoArgsFromtipohabitacionRecursive3(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive4'


class FindManyEmpleadoArgsFromtipohabitacionRecursive4(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    
    

class tipohabitacionIncludeFromtipohabitacion(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromtipohabitacionRecursive1']


class tipohabitacionIncludeFromtipohabitacionRecursive1(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromtipohabitacionRecursive2']


class tipohabitacionIncludeFromtipohabitacionRecursive2(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromtipohabitacionRecursive3']


class tipohabitacionIncludeFromtipohabitacionRecursive3(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromtipohabitacionRecursive4']


class tipohabitacionIncludeFromtipohabitacionRecursive4(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""

    

class tipohabitacionArgsFromtipohabitacion(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive1'


class tipohabitacionArgsFromtipohabitacionRecursive1(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive2'


class tipohabitacionArgsFromtipohabitacionRecursive2(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive3'


class tipohabitacionArgsFromtipohabitacionRecursive3(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive4'


class tipohabitacionArgsFromtipohabitacionRecursive4(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    
    

class FindManytipohabitacionArgsFromtipohabitacion(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive1'


class FindManytipohabitacionArgsFromtipohabitacionRecursive1(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive2'


class FindManytipohabitacionArgsFromtipohabitacionRecursive2(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive3'


class FindManytipohabitacionArgsFromtipohabitacionRecursive3(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive4'


class FindManytipohabitacionArgsFromtipohabitacionRecursive4(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    
    

class habitacionesIncludeFromtipohabitacion(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    Usuario: Union[bool, 'UsuarioArgsFromtipohabitacionRecursive1']
    tipo: Union[bool, 'tipohabitacionArgsFromtipohabitacionRecursive1']


class habitacionesIncludeFromtipohabitacionRecursive1(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    Usuario: Union[bool, 'UsuarioArgsFromtipohabitacionRecursive2']
    tipo: Union[bool, 'tipohabitacionArgsFromtipohabitacionRecursive2']


class habitacionesIncludeFromtipohabitacionRecursive2(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    Usuario: Union[bool, 'UsuarioArgsFromtipohabitacionRecursive3']
    tipo: Union[bool, 'tipohabitacionArgsFromtipohabitacionRecursive3']


class habitacionesIncludeFromtipohabitacionRecursive3(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""
    Usuario: Union[bool, 'UsuarioArgsFromtipohabitacionRecursive4']
    tipo: Union[bool, 'tipohabitacionArgsFromtipohabitacionRecursive4']


class habitacionesIncludeFromtipohabitacionRecursive4(TypedDict, total=False):
    """Relational arguments for tipohabitacion"""

    

class habitacionesArgsFromtipohabitacion(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'habitacionesIncludeFromhabitacionesRecursive1'


class habitacionesArgsFromtipohabitacionRecursive1(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'habitacionesIncludeFromhabitacionesRecursive2'


class habitacionesArgsFromtipohabitacionRecursive2(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'habitacionesIncludeFromhabitacionesRecursive3'


class habitacionesArgsFromtipohabitacionRecursive3(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    include: 'habitacionesIncludeFromhabitacionesRecursive4'


class habitacionesArgsFromtipohabitacionRecursive4(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    
    

class FindManyhabitacionesArgsFromtipohabitacion(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive1'


class FindManyhabitacionesArgsFromtipohabitacionRecursive1(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive2'


class FindManyhabitacionesArgsFromtipohabitacionRecursive2(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive3'


class FindManyhabitacionesArgsFromtipohabitacionRecursive3(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive4'


class FindManyhabitacionesArgsFromtipohabitacionRecursive4(TypedDict, total=False):
    """Arguments for tipohabitacion"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    


FindManytipohabitacionArgs = FindManytipohabitacionArgsFromtipohabitacion
FindFirsttipohabitacionArgs = FindManytipohabitacionArgsFromtipohabitacion


    

class tipohabitacionWhereInput(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    tipo: Union[None, _str, 'types.StringFilter']
    descripcion: Union[_str, 'types.StringFilter']
    habitaciones: 'habitacionesListRelationFilter'

    # should be noted that AND and NOT should be Union['tipohabitacionWhereInputRecursive1', List['tipohabitacionWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['tipohabitacionWhereInputRecursive1']
    OR: List['tipohabitacionWhereInputRecursive1']
    NOT: List['tipohabitacionWhereInputRecursive1']


class tipohabitacionWhereInputRecursive1(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    tipo: Union[None, _str, 'types.StringFilter']
    descripcion: Union[_str, 'types.StringFilter']
    habitaciones: 'habitacionesListRelationFilter'

    # should be noted that AND and NOT should be Union['tipohabitacionWhereInputRecursive2', List['tipohabitacionWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['tipohabitacionWhereInputRecursive2']
    OR: List['tipohabitacionWhereInputRecursive2']
    NOT: List['tipohabitacionWhereInputRecursive2']


class tipohabitacionWhereInputRecursive2(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    tipo: Union[None, _str, 'types.StringFilter']
    descripcion: Union[_str, 'types.StringFilter']
    habitaciones: 'habitacionesListRelationFilter'

    # should be noted that AND and NOT should be Union['tipohabitacionWhereInputRecursive3', List['tipohabitacionWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['tipohabitacionWhereInputRecursive3']
    OR: List['tipohabitacionWhereInputRecursive3']
    NOT: List['tipohabitacionWhereInputRecursive3']


class tipohabitacionWhereInputRecursive3(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    tipo: Union[None, _str, 'types.StringFilter']
    descripcion: Union[_str, 'types.StringFilter']
    habitaciones: 'habitacionesListRelationFilter'

    # should be noted that AND and NOT should be Union['tipohabitacionWhereInputRecursive4', List['tipohabitacionWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['tipohabitacionWhereInputRecursive4']
    OR: List['tipohabitacionWhereInputRecursive4']
    NOT: List['tipohabitacionWhereInputRecursive4']


class tipohabitacionWhereInputRecursive4(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    tipo: Union[None, _str, 'types.StringFilter']
    descripcion: Union[_str, 'types.StringFilter']
    habitaciones: 'habitacionesListRelationFilter'



# aggregate tipohabitacion types


    

class tipohabitacionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    tipo: Union[_str, 'types.StringWithAggregatesFilter']
    descripcion: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['tipohabitacionScalarWhereWithAggregatesInputRecursive1']
    OR: List['tipohabitacionScalarWhereWithAggregatesInputRecursive1']
    NOT: List['tipohabitacionScalarWhereWithAggregatesInputRecursive1']


class tipohabitacionScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    tipo: Union[_str, 'types.StringWithAggregatesFilter']
    descripcion: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['tipohabitacionScalarWhereWithAggregatesInputRecursive2']
    OR: List['tipohabitacionScalarWhereWithAggregatesInputRecursive2']
    NOT: List['tipohabitacionScalarWhereWithAggregatesInputRecursive2']


class tipohabitacionScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    tipo: Union[_str, 'types.StringWithAggregatesFilter']
    descripcion: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['tipohabitacionScalarWhereWithAggregatesInputRecursive3']
    OR: List['tipohabitacionScalarWhereWithAggregatesInputRecursive3']
    NOT: List['tipohabitacionScalarWhereWithAggregatesInputRecursive3']


class tipohabitacionScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    tipo: Union[_str, 'types.StringWithAggregatesFilter']
    descripcion: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['tipohabitacionScalarWhereWithAggregatesInputRecursive4']
    OR: List['tipohabitacionScalarWhereWithAggregatesInputRecursive4']
    NOT: List['tipohabitacionScalarWhereWithAggregatesInputRecursive4']


class tipohabitacionScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """tipohabitacion arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    tipo: Union[_str, 'types.StringWithAggregatesFilter']
    descripcion: Union[_str, 'types.StringWithAggregatesFilter']



class tipohabitacionGroupByOutput(TypedDict, total=False):
    id: _int
    tipo: _str
    descripcion: _str
    _sum: 'tipohabitacionSumAggregateOutput'
    _avg: 'tipohabitacionAvgAggregateOutput'
    _min: 'tipohabitacionMinAggregateOutput'
    _max: 'tipohabitacionMaxAggregateOutput'
    _count: 'tipohabitacionCountAggregateOutput'


class tipohabitacionAvgAggregateOutput(TypedDict, total=False):
    """tipohabitacion output for aggregating averages"""
    id: float


class tipohabitacionSumAggregateOutput(TypedDict, total=False):
    """tipohabitacion output for aggregating sums"""
    id: _int


class tipohabitacionScalarAggregateOutput(TypedDict, total=False):
    """tipohabitacion output including scalar fields"""
    id: _int
    tipo: _str
    descripcion: _str


tipohabitacionMinAggregateOutput = tipohabitacionScalarAggregateOutput
tipohabitacionMaxAggregateOutput = tipohabitacionScalarAggregateOutput


class tipohabitacionMaxAggregateInput(TypedDict, total=False):
    """tipohabitacion input for aggregating by max"""
    id: bool
    tipo: bool
    descripcion: bool


class tipohabitacionMinAggregateInput(TypedDict, total=False):
    """tipohabitacion input for aggregating by min"""
    id: bool
    tipo: bool
    descripcion: bool


class tipohabitacionNumberAggregateInput(TypedDict, total=False):
    """tipohabitacion input for aggregating numbers"""
    id: bool


tipohabitacionAvgAggregateInput = tipohabitacionNumberAggregateInput
tipohabitacionSumAggregateInput = tipohabitacionNumberAggregateInput


tipohabitacionCountAggregateInput = TypedDict(
    'tipohabitacionCountAggregateInput',
    {
        'id': bool,
        'tipo': bool,
        'descripcion': bool,
        '_all': bool,
    },
    total=False,
)

tipohabitacionCountAggregateOutput = TypedDict(
    'tipohabitacionCountAggregateOutput',
    {
        'id': int,
        'tipo': int,
        'descripcion': int,
        '_all': int,
    },
    total=False,
)


tipohabitacionKeys = Literal[
    'id',
    'tipo',
    'descripcion',
    'habitaciones',
]
tipohabitacionScalarFieldKeys = Literal[
    'id',
    'tipo',
    'descripcion',
]
tipohabitacionScalarFieldKeysT = TypeVar('tipohabitacionScalarFieldKeysT', bound=tipohabitacionScalarFieldKeys)

tipohabitacionRelationalFieldKeys = Literal[
        'habitaciones',
    ]

# habitaciones types

class habitacionesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the habitaciones create method"""
    id: _int
    Usuario: 'UsuarioCreateNestedWithoutRelationsInput'
    tipo: 'tipohabitacionCreateNestedWithoutRelationsInput'
    tipohabitacionId: _int


class habitacionesCreateInput(habitacionesOptionalCreateInput):
    """Required arguments to the habitaciones create method"""
    numero: _str
    costo: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class habitacionesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the habitaciones create method, without relations"""
    id: _int
    tipohabitacionId: _int


class habitacionesCreateWithoutRelationsInput(habitacionesOptionalCreateWithoutRelationsInput):
    """Required arguments to the habitaciones create method, without relations"""
    numero: _str
    costo: _str


class habitacionesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'habitacionesCreateWithoutRelationsInput'
    connect: 'habitacionesWhereUniqueInput'


class habitacionesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['habitacionesCreateWithoutRelationsInput', List['habitacionesCreateWithoutRelationsInput']]
    connect: Union['habitacionesWhereUniqueInput', List['habitacionesWhereUniqueInput']]


_habitacionesWhereUnique_id_Input = TypedDict(
    '_habitacionesWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

habitacionesWhereUniqueInput = _habitacionesWhereUnique_id_Input


class habitacionesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    Usuario: 'UsuarioUpdateOneWithoutRelationsInput'
    numero: _str
    tipo: 'tipohabitacionUpdateOneWithoutRelationsInput'
    costo: _str


class habitacionesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    numero: _str
    costo: _str


class habitacionesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['habitacionesCreateWithoutRelationsInput']
    connect: List['habitacionesWhereUniqueInput']
    set: List['habitacionesWhereUniqueInput']
    disconnect: List['habitacionesWhereUniqueInput']
    delete: List['habitacionesWhereUniqueInput']

    # TODO
    # update: List['habitacionesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['habitacionesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['habitacionesScalarWhereInput']
    # upsert: List['habitacionesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['habitacionesCreateOrConnectWithoutRelationsInput']


class habitacionesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'habitacionesCreateWithoutRelationsInput'
    connect: 'habitacionesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'habitacionesUpdateInput'
    # upsert: 'habitacionesUpsertWithoutRelationsInput'
    # connectOrCreate: 'habitacionesCreateOrConnectWithoutRelationsInput'


class habitacionesUpsertInput(TypedDict):
    create: 'habitacionesCreateInput'
    update: 'habitacionesUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_habitaciones_id_OrderByInput = TypedDict(
    '_habitaciones_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_habitaciones_numero_OrderByInput = TypedDict(
    '_habitaciones_numero_OrderByInput',
    {
        'numero': 'SortOrder',
    },
    total=True
)

_habitaciones_tipohabitacionId_OrderByInput = TypedDict(
    '_habitaciones_tipohabitacionId_OrderByInput',
    {
        'tipohabitacionId': 'SortOrder',
    },
    total=True
)

_habitaciones_costo_OrderByInput = TypedDict(
    '_habitaciones_costo_OrderByInput',
    {
        'costo': 'SortOrder',
    },
    total=True
)

habitacionesOrderByInput = Union[
    '_habitaciones_id_OrderByInput',
    '_habitaciones_numero_OrderByInput',
    '_habitaciones_tipohabitacionId_OrderByInput',
    '_habitaciones_costo_OrderByInput',
]



# recursive habitaciones types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

habitacionesRelationFilter = TypedDict(
    'habitacionesRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class habitacionesListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class habitacionesInclude(TypedDict, total=False):
    """habitaciones relational arguments"""
    Usuario: Union[bool, 'UsuarioArgsFromhabitaciones']
    tipo: Union[bool, 'tipohabitacionArgsFromhabitaciones']


    

class UsuarioIncludeFromhabitaciones(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    cuarto: Union[bool, 'habitacionesArgsFromhabitacionesRecursive1']


class UsuarioIncludeFromhabitacionesRecursive1(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    cuarto: Union[bool, 'habitacionesArgsFromhabitacionesRecursive2']


class UsuarioIncludeFromhabitacionesRecursive2(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    cuarto: Union[bool, 'habitacionesArgsFromhabitacionesRecursive3']


class UsuarioIncludeFromhabitacionesRecursive3(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    cuarto: Union[bool, 'habitacionesArgsFromhabitacionesRecursive4']


class UsuarioIncludeFromhabitacionesRecursive4(TypedDict, total=False):
    """Relational arguments for habitaciones"""

    

class UsuarioArgsFromhabitaciones(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'UsuarioIncludeFromUsuarioRecursive1'


class UsuarioArgsFromhabitacionesRecursive1(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'UsuarioIncludeFromUsuarioRecursive2'


class UsuarioArgsFromhabitacionesRecursive2(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'UsuarioIncludeFromUsuarioRecursive3'


class UsuarioArgsFromhabitacionesRecursive3(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'UsuarioIncludeFromUsuarioRecursive4'


class UsuarioArgsFromhabitacionesRecursive4(TypedDict, total=False):
    """Arguments for habitaciones"""
    
    

class FindManyUsuarioArgsFromhabitaciones(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive1'


class FindManyUsuarioArgsFromhabitacionesRecursive1(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive2'


class FindManyUsuarioArgsFromhabitacionesRecursive2(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive3'


class FindManyUsuarioArgsFromhabitacionesRecursive3(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    include: 'UsuarioIncludeFromUsuarioRecursive4'


class FindManyUsuarioArgsFromhabitacionesRecursive4(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['UsuarioOrderByInput', List['UsuarioOrderByInput']]
    where: 'UsuarioWhereInput'
    cursor: 'UsuarioWhereUniqueInput'
    distinct: List['UsuarioScalarFieldKeys']
    
    

class EmpleadoIncludeFromhabitaciones(TypedDict, total=False):
    """Relational arguments for habitaciones"""


class EmpleadoIncludeFromhabitacionesRecursive1(TypedDict, total=False):
    """Relational arguments for habitaciones"""


class EmpleadoIncludeFromhabitacionesRecursive2(TypedDict, total=False):
    """Relational arguments for habitaciones"""


class EmpleadoIncludeFromhabitacionesRecursive3(TypedDict, total=False):
    """Relational arguments for habitaciones"""


class EmpleadoIncludeFromhabitacionesRecursive4(TypedDict, total=False):
    """Relational arguments for habitaciones"""

    

class EmpleadoArgsFromhabitaciones(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive1'


class EmpleadoArgsFromhabitacionesRecursive1(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive2'


class EmpleadoArgsFromhabitacionesRecursive2(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive3'


class EmpleadoArgsFromhabitacionesRecursive3(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'EmpleadoIncludeFromEmpleadoRecursive4'


class EmpleadoArgsFromhabitacionesRecursive4(TypedDict, total=False):
    """Arguments for habitaciones"""
    
    

class FindManyEmpleadoArgsFromhabitaciones(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive1'


class FindManyEmpleadoArgsFromhabitacionesRecursive1(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive2'


class FindManyEmpleadoArgsFromhabitacionesRecursive2(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive3'


class FindManyEmpleadoArgsFromhabitacionesRecursive3(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    include: 'EmpleadoIncludeFromEmpleadoRecursive4'


class FindManyEmpleadoArgsFromhabitacionesRecursive4(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['EmpleadoOrderByInput', List['EmpleadoOrderByInput']]
    where: 'EmpleadoWhereInput'
    cursor: 'EmpleadoWhereUniqueInput'
    distinct: List['EmpleadoScalarFieldKeys']
    
    

class tipohabitacionIncludeFromhabitaciones(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromhabitacionesRecursive1']


class tipohabitacionIncludeFromhabitacionesRecursive1(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromhabitacionesRecursive2']


class tipohabitacionIncludeFromhabitacionesRecursive2(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromhabitacionesRecursive3']


class tipohabitacionIncludeFromhabitacionesRecursive3(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    habitaciones: Union[bool, 'FindManyhabitacionesArgsFromhabitacionesRecursive4']


class tipohabitacionIncludeFromhabitacionesRecursive4(TypedDict, total=False):
    """Relational arguments for habitaciones"""

    

class tipohabitacionArgsFromhabitaciones(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive1'


class tipohabitacionArgsFromhabitacionesRecursive1(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive2'


class tipohabitacionArgsFromhabitacionesRecursive2(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive3'


class tipohabitacionArgsFromhabitacionesRecursive3(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive4'


class tipohabitacionArgsFromhabitacionesRecursive4(TypedDict, total=False):
    """Arguments for habitaciones"""
    
    

class FindManytipohabitacionArgsFromhabitaciones(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive1'


class FindManytipohabitacionArgsFromhabitacionesRecursive1(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive2'


class FindManytipohabitacionArgsFromhabitacionesRecursive2(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive3'


class FindManytipohabitacionArgsFromhabitacionesRecursive3(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    include: 'tipohabitacionIncludeFromtipohabitacionRecursive4'


class FindManytipohabitacionArgsFromhabitacionesRecursive4(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['tipohabitacionOrderByInput', List['tipohabitacionOrderByInput']]
    where: 'tipohabitacionWhereInput'
    cursor: 'tipohabitacionWhereUniqueInput'
    distinct: List['tipohabitacionScalarFieldKeys']
    
    

class habitacionesIncludeFromhabitaciones(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    Usuario: Union[bool, 'UsuarioArgsFromhabitacionesRecursive1']
    tipo: Union[bool, 'tipohabitacionArgsFromhabitacionesRecursive1']


class habitacionesIncludeFromhabitacionesRecursive1(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    Usuario: Union[bool, 'UsuarioArgsFromhabitacionesRecursive2']
    tipo: Union[bool, 'tipohabitacionArgsFromhabitacionesRecursive2']


class habitacionesIncludeFromhabitacionesRecursive2(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    Usuario: Union[bool, 'UsuarioArgsFromhabitacionesRecursive3']
    tipo: Union[bool, 'tipohabitacionArgsFromhabitacionesRecursive3']


class habitacionesIncludeFromhabitacionesRecursive3(TypedDict, total=False):
    """Relational arguments for habitaciones"""
    Usuario: Union[bool, 'UsuarioArgsFromhabitacionesRecursive4']
    tipo: Union[bool, 'tipohabitacionArgsFromhabitacionesRecursive4']


class habitacionesIncludeFromhabitacionesRecursive4(TypedDict, total=False):
    """Relational arguments for habitaciones"""

    

class habitacionesArgsFromhabitaciones(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'habitacionesIncludeFromhabitacionesRecursive1'


class habitacionesArgsFromhabitacionesRecursive1(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'habitacionesIncludeFromhabitacionesRecursive2'


class habitacionesArgsFromhabitacionesRecursive2(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'habitacionesIncludeFromhabitacionesRecursive3'


class habitacionesArgsFromhabitacionesRecursive3(TypedDict, total=False):
    """Arguments for habitaciones"""
    include: 'habitacionesIncludeFromhabitacionesRecursive4'


class habitacionesArgsFromhabitacionesRecursive4(TypedDict, total=False):
    """Arguments for habitaciones"""
    
    

class FindManyhabitacionesArgsFromhabitaciones(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive1'


class FindManyhabitacionesArgsFromhabitacionesRecursive1(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive2'


class FindManyhabitacionesArgsFromhabitacionesRecursive2(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive3'


class FindManyhabitacionesArgsFromhabitacionesRecursive3(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    include: 'habitacionesIncludeFromhabitacionesRecursive4'


class FindManyhabitacionesArgsFromhabitacionesRecursive4(TypedDict, total=False):
    """Arguments for habitaciones"""
    take: int
    skip: int
    order_by: Union['habitacionesOrderByInput', List['habitacionesOrderByInput']]
    where: 'habitacionesWhereInput'
    cursor: 'habitacionesWhereUniqueInput'
    distinct: List['habitacionesScalarFieldKeys']
    


FindManyhabitacionesArgs = FindManyhabitacionesArgsFromhabitaciones
FindFirsthabitacionesArgs = FindManyhabitacionesArgsFromhabitaciones


    

class habitacionesWhereInput(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Usuario: 'UsuarioRelationFilter'
    numero: Union[_str, 'types.StringFilter']
    tipo: 'tipohabitacionRelationFilter'
    tipohabitacionId: Union[_int, 'types.IntFilter']
    costo: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['habitacionesWhereInputRecursive1', List['habitacionesWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['habitacionesWhereInputRecursive1']
    OR: List['habitacionesWhereInputRecursive1']
    NOT: List['habitacionesWhereInputRecursive1']


class habitacionesWhereInputRecursive1(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Usuario: 'UsuarioRelationFilter'
    numero: Union[_str, 'types.StringFilter']
    tipo: 'tipohabitacionRelationFilter'
    tipohabitacionId: Union[_int, 'types.IntFilter']
    costo: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['habitacionesWhereInputRecursive2', List['habitacionesWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['habitacionesWhereInputRecursive2']
    OR: List['habitacionesWhereInputRecursive2']
    NOT: List['habitacionesWhereInputRecursive2']


class habitacionesWhereInputRecursive2(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Usuario: 'UsuarioRelationFilter'
    numero: Union[_str, 'types.StringFilter']
    tipo: 'tipohabitacionRelationFilter'
    tipohabitacionId: Union[_int, 'types.IntFilter']
    costo: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['habitacionesWhereInputRecursive3', List['habitacionesWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['habitacionesWhereInputRecursive3']
    OR: List['habitacionesWhereInputRecursive3']
    NOT: List['habitacionesWhereInputRecursive3']


class habitacionesWhereInputRecursive3(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Usuario: 'UsuarioRelationFilter'
    numero: Union[_str, 'types.StringFilter']
    tipo: 'tipohabitacionRelationFilter'
    tipohabitacionId: Union[_int, 'types.IntFilter']
    costo: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['habitacionesWhereInputRecursive4', List['habitacionesWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['habitacionesWhereInputRecursive4']
    OR: List['habitacionesWhereInputRecursive4']
    NOT: List['habitacionesWhereInputRecursive4']


class habitacionesWhereInputRecursive4(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    Usuario: 'UsuarioRelationFilter'
    numero: Union[_str, 'types.StringFilter']
    tipo: 'tipohabitacionRelationFilter'
    tipohabitacionId: Union[_int, 'types.IntFilter']
    costo: Union[_str, 'types.StringFilter']



# aggregate habitaciones types


    

class habitacionesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    numero: Union[_str, 'types.StringWithAggregatesFilter']
    tipohabitacionId: Union[_int, 'types.IntWithAggregatesFilter']
    costo: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['habitacionesScalarWhereWithAggregatesInputRecursive1']
    OR: List['habitacionesScalarWhereWithAggregatesInputRecursive1']
    NOT: List['habitacionesScalarWhereWithAggregatesInputRecursive1']


class habitacionesScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    numero: Union[_str, 'types.StringWithAggregatesFilter']
    tipohabitacionId: Union[_int, 'types.IntWithAggregatesFilter']
    costo: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['habitacionesScalarWhereWithAggregatesInputRecursive2']
    OR: List['habitacionesScalarWhereWithAggregatesInputRecursive2']
    NOT: List['habitacionesScalarWhereWithAggregatesInputRecursive2']


class habitacionesScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    numero: Union[_str, 'types.StringWithAggregatesFilter']
    tipohabitacionId: Union[_int, 'types.IntWithAggregatesFilter']
    costo: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['habitacionesScalarWhereWithAggregatesInputRecursive3']
    OR: List['habitacionesScalarWhereWithAggregatesInputRecursive3']
    NOT: List['habitacionesScalarWhereWithAggregatesInputRecursive3']


class habitacionesScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    numero: Union[_str, 'types.StringWithAggregatesFilter']
    tipohabitacionId: Union[_int, 'types.IntWithAggregatesFilter']
    costo: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['habitacionesScalarWhereWithAggregatesInputRecursive4']
    OR: List['habitacionesScalarWhereWithAggregatesInputRecursive4']
    NOT: List['habitacionesScalarWhereWithAggregatesInputRecursive4']


class habitacionesScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """habitaciones arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    numero: Union[_str, 'types.StringWithAggregatesFilter']
    tipohabitacionId: Union[_int, 'types.IntWithAggregatesFilter']
    costo: Union[_str, 'types.StringWithAggregatesFilter']



class habitacionesGroupByOutput(TypedDict, total=False):
    id: _int
    numero: _str
    tipohabitacionId: _int
    costo: _str
    _sum: 'habitacionesSumAggregateOutput'
    _avg: 'habitacionesAvgAggregateOutput'
    _min: 'habitacionesMinAggregateOutput'
    _max: 'habitacionesMaxAggregateOutput'
    _count: 'habitacionesCountAggregateOutput'


class habitacionesAvgAggregateOutput(TypedDict, total=False):
    """habitaciones output for aggregating averages"""
    id: float
    tipohabitacionId: float


class habitacionesSumAggregateOutput(TypedDict, total=False):
    """habitaciones output for aggregating sums"""
    id: _int
    tipohabitacionId: _int


class habitacionesScalarAggregateOutput(TypedDict, total=False):
    """habitaciones output including scalar fields"""
    id: _int
    numero: _str
    tipohabitacionId: _int
    costo: _str


habitacionesMinAggregateOutput = habitacionesScalarAggregateOutput
habitacionesMaxAggregateOutput = habitacionesScalarAggregateOutput


class habitacionesMaxAggregateInput(TypedDict, total=False):
    """habitaciones input for aggregating by max"""
    id: bool
    numero: bool
    tipohabitacionId: bool
    costo: bool


class habitacionesMinAggregateInput(TypedDict, total=False):
    """habitaciones input for aggregating by min"""
    id: bool
    numero: bool
    tipohabitacionId: bool
    costo: bool


class habitacionesNumberAggregateInput(TypedDict, total=False):
    """habitaciones input for aggregating numbers"""
    id: bool
    tipohabitacionId: bool


habitacionesAvgAggregateInput = habitacionesNumberAggregateInput
habitacionesSumAggregateInput = habitacionesNumberAggregateInput


habitacionesCountAggregateInput = TypedDict(
    'habitacionesCountAggregateInput',
    {
        'id': bool,
        'numero': bool,
        'tipohabitacionId': bool,
        'costo': bool,
        '_all': bool,
    },
    total=False,
)

habitacionesCountAggregateOutput = TypedDict(
    'habitacionesCountAggregateOutput',
    {
        'id': int,
        'numero': int,
        'tipohabitacionId': int,
        'costo': int,
        '_all': int,
    },
    total=False,
)


habitacionesKeys = Literal[
    'id',
    'Usuario',
    'numero',
    'tipo',
    'tipohabitacionId',
    'costo',
]
habitacionesScalarFieldKeys = Literal[
    'id',
    'numero',
    'tipohabitacionId',
    'costo',
]
habitacionesScalarFieldKeysT = TypeVar('habitacionesScalarFieldKeysT', bound=habitacionesScalarFieldKeys)

habitacionesRelationalFieldKeys = Literal[
        'Usuario',
        'tipo',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields