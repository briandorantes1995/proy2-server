# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UsuarioActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Usuario]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Usuario.prisma().query_raw(
            'SELECT * FROM Usuario WHERE id = ?',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Usuario
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Usuario.prisma().query_first(
            'SELECT * FROM Usuario WHERE nombre = ?',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UsuarioCreateInput,
        include: Optional[types.UsuarioInclude] = None
    ) -> _PrismaModelT:
        """Create a new Usuario record.

        Parameters
        ----------
        data
            Usuario record data
        include
            Specifies which relations should be loaded on the returned Usuario model

        Returns
        -------
        prisma.models.Usuario
            The created Usuario record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Usuario record from just the required fields
        usuario = await Usuario.prisma().create(
            data={
                # data to create a Usuario record
                'nombre': 'ggciceaie',
                'email': 'bbehjachib',
                'password': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UsuarioCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Usuario records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Usuario record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Usuario.prisma().create_many(
            data=[
                {
                    # data to create a Usuario record
                    'nombre': 'dgiiaaijj',
                    'email': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
                {
                    # data to create a Usuario record
                    'nombre': 'bagcfbhiig',
                    'email': 'cghideieh',
                    'password': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UsuarioWhereUniqueInput,
        include: Optional[types.UsuarioInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Usuario record.

        Parameters
        ----------
        where
            Usuario filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Usuario model

        Returns
        -------
        prisma.models.Usuario
            The deleted Usuario record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usuario = await Usuario.prisma().delete(
            where={
                'id': 836760821,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UsuarioWhereUniqueInput,
        include: Optional[types.UsuarioInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Usuario record.

        Parameters
        ----------
        where
            Usuario filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Usuario model

        Returns
        -------
        prisma.models.Usuario
            The found Usuario record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usuario = await Usuario.prisma().find_unique(
            where={
                'id': 595337866,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UsuarioWhereUniqueInput,
        include: Optional[types.UsuarioInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Usuario record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Usuario filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Usuario model

        Returns
        -------
        prisma.models.Usuario
            The found Usuario record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usuario = await Usuario.prisma().find_unique_or_raise(
            where={
                'id': 790425851,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsuarioWhereInput] = None,
        cursor: Optional[types.UsuarioWhereUniqueInput] = None,
        include: Optional[types.UsuarioInclude] = None,
        order: Optional[Union[types.UsuarioOrderByInput, List[types.UsuarioOrderByInput]]] = None,
        distinct: Optional[List[types.UsuarioScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Usuario records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Usuario records returned
        skip
            Ignore the first N results
        where
            Usuario filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Usuario model
        order
            Order the returned Usuario records by any field
        distinct
            Filter Usuario records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Usuario]
            The list of all Usuario records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Usuario records
        usuarios = await Usuario.prisma().find_many(take=10)

        # find the first 5 Usuario records ordered by the email field
        usuarios = await Usuario.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UsuarioWhereInput] = None,
        cursor: Optional[types.UsuarioWhereUniqueInput] = None,
        include: Optional[types.UsuarioInclude] = None,
        order: Optional[Union[types.UsuarioOrderByInput, List[types.UsuarioOrderByInput]]] = None,
        distinct: Optional[List[types.UsuarioScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Usuario record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Usuario filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Usuario model
        order
            Order the returned Usuario records by any field
        distinct
            Filter Usuario records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Usuario
            The first Usuario record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Usuario record ordered by the password field
        usuario = await Usuario.prisma().find_first(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UsuarioWhereInput] = None,
        cursor: Optional[types.UsuarioWhereUniqueInput] = None,
        include: Optional[types.UsuarioInclude] = None,
        order: Optional[Union[types.UsuarioOrderByInput, List[types.UsuarioOrderByInput]]] = None,
        distinct: Optional[List[types.UsuarioScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Usuario record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Usuario filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Usuario model
        order
            Order the returned Usuario records by any field
        distinct
            Filter Usuario records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Usuario
            The first Usuario record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Usuario record ordered by the hospedado field
        usuario = await Usuario.prisma().find_first_or_raise(
            skip=1,
            order={
                'hospedado': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UsuarioUpdateInput,
        where: types.UsuarioWhereUniqueInput,
        include: Optional[types.UsuarioInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Usuario record.

        Parameters
        ----------
        data
            Usuario record data specifying what to update
        where
            Usuario filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Usuario model

        Returns
        -------
        prisma.models.Usuario
            The updated Usuario record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usuario = await Usuario.prisma().update(
            where={
                'id': 2111915288,
            },
            data={
                # data to update the Usuario record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UsuarioWhereUniqueInput,
        data: types.UsuarioUpsertInput,
        include: Optional[types.UsuarioInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Usuario filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Usuario model

        Returns
        -------
        prisma.models.Usuario
            The created or updated Usuario record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usuario = await Usuario.prisma().upsert(
            where={
                'id': 1149758321,
            },
            data={
                'create': {
                    'id': 1149758321,
                    'nombre': 'bagcfbhiig',
                    'email': 'cghideieh',
                    'password': 'biabhbdai',
                },
                'update': {
                    'nombre': 'bagcfbhiig',
                    'email': 'cghideieh',
                    'password': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UsuarioUpdateManyMutationInput,
        where: types.UsuarioWhereInput,
    ) -> int:
        """Update multiple Usuario records

        Parameters
        ----------
        data
            Usuario data to update the selected Usuario records to
        where
            Filter to select the Usuario records to update

        Returns
        -------
        int
            The total number of Usuario records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Usuario records
        total = await Usuario.prisma().update_many(
            data={
                'habitacionesId': 1644289366
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsuarioWhereInput] = None,
        cursor: Optional[types.UsuarioWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Usuario records present in the database

        Parameters
        ----------
        select
            Select the Usuario fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Usuario filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsuarioCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Usuario.prisma().count()

        # results: prisma.types.UsuarioCountAggregateOutput
        results = await Usuario.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UsuarioCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsuarioWhereInput] = None,
        cursor: Optional[types.UsuarioWhereUniqueInput] = None,
    ) -> types.UsuarioCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UsuarioCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsuarioWhereInput] = None,
        cursor: Optional[types.UsuarioWhereUniqueInput] = None,
    ) -> Union[int, types.UsuarioCountAggregateOutput]:
        """Count the number of Usuario records present in the database

        Parameters
        ----------
        select
            Select the Usuario fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Usuario filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsuarioCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Usuario.prisma().count()

        # results: prisma.types.UsuarioCountAggregateOutput
        results = await Usuario.prisma().count(
            select={
                '_all': True,
                'nombre': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UsuarioCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UsuarioWhereInput] = None
    ) -> int:
        """Delete multiple Usuario records.

        Parameters
        ----------
        where
            Optional Usuario filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Usuario records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Usuario records
        total = await Usuario.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UsuarioScalarFieldKeys'],
        *,
        where: Optional['types.UsuarioWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UsuarioAvgAggregateInput'] = None,
        sum: Optional['types.UsuarioSumAggregateInput'] = None,
        min: Optional['types.UsuarioMinAggregateInput'] = None,
        max: Optional['types.UsuarioMaxAggregateInput'] = None,
        having: Optional['types.UsuarioScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UsuarioCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UsuarioScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UsuarioScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UsuarioGroupByOutput']:
        """Group Usuario records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Usuario fields to group records by
        where
            Usuario filter to select records
        take
            Limit the maximum number of Usuario records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UsuarioGroupByOutput]
            A list of dictionaries representing the Usuario record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Usuario records by email values
        # and count how many records are in each group
        results = await Usuario.prisma().group_by(
            ['email'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmpleadoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Empleado]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Empleado.prisma().query_raw(
            'SELECT * FROM Empleado WHERE id = ?',
            1388290519,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Empleado
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Empleado.prisma().query_first(
            'SELECT * FROM Empleado WHERE nombre = ?',
            'bgehebiafc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmpleadoCreateInput,
        include: Optional[types.EmpleadoInclude] = None
    ) -> _PrismaModelT:
        """Create a new Empleado record.

        Parameters
        ----------
        data
            Empleado record data
        include
            Specifies which relations should be loaded on the returned Empleado model

        Returns
        -------
        prisma.models.Empleado
            The created Empleado record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Empleado record from just the required fields
        empleado = await Empleado.prisma().create(
            data={
                # data to create a Empleado record
                'email': 'bghffegacj',
                'password': 'bhghchehcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmpleadoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Empleado records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Empleado record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Empleado.prisma().create_many(
            data=[
                {
                    # data to create a Empleado record
                    'email': 'dcgchcbbf',
                    'password': 'bdedcabahc',
                },
                {
                    # data to create a Empleado record
                    'email': 'ghfhiafcb',
                    'password': 'heejgedji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmpleadoWhereUniqueInput,
        include: Optional[types.EmpleadoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Empleado record.

        Parameters
        ----------
        where
            Empleado filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Empleado model

        Returns
        -------
        prisma.models.Empleado
            The deleted Empleado record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        empleado = await Empleado.prisma().delete(
            where={
                'id': 1969681615,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmpleadoWhereUniqueInput,
        include: Optional[types.EmpleadoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Empleado record.

        Parameters
        ----------
        where
            Empleado filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Empleado model

        Returns
        -------
        prisma.models.Empleado
            The found Empleado record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        empleado = await Empleado.prisma().find_unique(
            where={
                'id': 1116175964,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmpleadoWhereUniqueInput,
        include: Optional[types.EmpleadoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Empleado record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Empleado filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Empleado model

        Returns
        -------
        prisma.models.Empleado
            The found Empleado record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        empleado = await Empleado.prisma().find_unique_or_raise(
            where={
                'id': 861472101,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmpleadoWhereInput] = None,
        cursor: Optional[types.EmpleadoWhereUniqueInput] = None,
        include: Optional[types.EmpleadoInclude] = None,
        order: Optional[Union[types.EmpleadoOrderByInput, List[types.EmpleadoOrderByInput]]] = None,
        distinct: Optional[List[types.EmpleadoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Empleado records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Empleado records returned
        skip
            Ignore the first N results
        where
            Empleado filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Empleado model
        order
            Order the returned Empleado records by any field
        distinct
            Filter Empleado records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Empleado]
            The list of all Empleado records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Empleado records
        empleados = await Empleado.prisma().find_many(take=10)

        # find the first 5 Empleado records ordered by the email field
        empleados = await Empleado.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmpleadoWhereInput] = None,
        cursor: Optional[types.EmpleadoWhereUniqueInput] = None,
        include: Optional[types.EmpleadoInclude] = None,
        order: Optional[Union[types.EmpleadoOrderByInput, List[types.EmpleadoOrderByInput]]] = None,
        distinct: Optional[List[types.EmpleadoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Empleado record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Empleado filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Empleado model
        order
            Order the returned Empleado records by any field
        distinct
            Filter Empleado records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Empleado
            The first Empleado record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Empleado record ordered by the password field
        empleado = await Empleado.prisma().find_first(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmpleadoWhereInput] = None,
        cursor: Optional[types.EmpleadoWhereUniqueInput] = None,
        include: Optional[types.EmpleadoInclude] = None,
        order: Optional[Union[types.EmpleadoOrderByInput, List[types.EmpleadoOrderByInput]]] = None,
        distinct: Optional[List[types.EmpleadoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Empleado record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Empleado filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Empleado model
        order
            Order the returned Empleado records by any field
        distinct
            Filter Empleado records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Empleado
            The first Empleado record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Empleado record ordered by the rol field
        empleado = await Empleado.prisma().find_first_or_raise(
            skip=1,
            order={
                'rol': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmpleadoUpdateInput,
        where: types.EmpleadoWhereUniqueInput,
        include: Optional[types.EmpleadoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Empleado record.

        Parameters
        ----------
        data
            Empleado record data specifying what to update
        where
            Empleado filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Empleado model

        Returns
        -------
        prisma.models.Empleado
            The updated Empleado record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        empleado = await Empleado.prisma().update(
            where={
                'id': 1303003706,
            },
            data={
                # data to update the Empleado record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmpleadoWhereUniqueInput,
        data: types.EmpleadoUpsertInput,
        include: Optional[types.EmpleadoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Empleado filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Empleado model

        Returns
        -------
        prisma.models.Empleado
            The created or updated Empleado record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        empleado = await Empleado.prisma().upsert(
            where={
                'id': 1686638315,
            },
            data={
                'create': {
                    'id': 1686638315,
                    'email': 'ghfhiafcb',
                    'password': 'heejgedji',
                },
                'update': {
                    'email': 'ghfhiafcb',
                    'password': 'heejgedji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmpleadoUpdateManyMutationInput,
        where: types.EmpleadoWhereInput,
    ) -> int:
        """Update multiple Empleado records

        Parameters
        ----------
        data
            Empleado data to update the selected Empleado records to
        where
            Filter to select the Empleado records to update

        Returns
        -------
        int
            The total number of Empleado records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Empleado records
        total = await Empleado.prisma().update_many(
            data={
                'id': 2000430152
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmpleadoWhereInput] = None,
        cursor: Optional[types.EmpleadoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Empleado records present in the database

        Parameters
        ----------
        select
            Select the Empleado fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Empleado filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmpleadoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Empleado.prisma().count()

        # results: prisma.types.EmpleadoCountAggregateOutput
        results = await Empleado.prisma().count(
            select={
                '_all': True,
                'nombre': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmpleadoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmpleadoWhereInput] = None,
        cursor: Optional[types.EmpleadoWhereUniqueInput] = None,
    ) -> types.EmpleadoCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmpleadoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmpleadoWhereInput] = None,
        cursor: Optional[types.EmpleadoWhereUniqueInput] = None,
    ) -> Union[int, types.EmpleadoCountAggregateOutput]:
        """Count the number of Empleado records present in the database

        Parameters
        ----------
        select
            Select the Empleado fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Empleado filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmpleadoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Empleado.prisma().count()

        # results: prisma.types.EmpleadoCountAggregateOutput
        results = await Empleado.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmpleadoCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmpleadoWhereInput] = None
    ) -> int:
        """Delete multiple Empleado records.

        Parameters
        ----------
        where
            Optional Empleado filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Empleado records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Empleado records
        total = await Empleado.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmpleadoScalarFieldKeys'],
        *,
        where: Optional['types.EmpleadoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmpleadoAvgAggregateInput'] = None,
        sum: Optional['types.EmpleadoSumAggregateInput'] = None,
        min: Optional['types.EmpleadoMinAggregateInput'] = None,
        max: Optional['types.EmpleadoMaxAggregateInput'] = None,
        having: Optional['types.EmpleadoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmpleadoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmpleadoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmpleadoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmpleadoGroupByOutput']:
        """Group Empleado records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Empleado fields to group records by
        where
            Empleado filter to select records
        take
            Limit the maximum number of Empleado records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmpleadoGroupByOutput]
            A list of dictionaries representing the Empleado record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Empleado records by password values
        # and count how many records are in each group
        results = await Empleado.prisma().group_by(
            ['password'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class tipohabitacionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.tipohabitacion]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await tipohabitacion.prisma().query_raw(
            'SELECT * FROM tipohabitacion WHERE id = ?',
            1868141281,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.tipohabitacion
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await tipohabitacion.prisma().query_first(
            'SELECT * FROM tipohabitacion WHERE tipo = ?',
            'bigaiehgcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.tipohabitacionCreateInput,
        include: Optional[types.tipohabitacionInclude] = None
    ) -> _PrismaModelT:
        """Create a new tipohabitacion record.

        Parameters
        ----------
        data
            tipohabitacion record data
        include
            Specifies which relations should be loaded on the returned tipohabitacion model

        Returns
        -------
        prisma.models.tipohabitacion
            The created tipohabitacion record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a tipohabitacion record from just the required fields
        tipohabitacion = await tipohabitacion.prisma().create(
            data={
                # data to create a tipohabitacion record
                'descripcion': 'beeifcbebf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.tipohabitacionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple tipohabitacion records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of tipohabitacion record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await tipohabitacion.prisma().create_many(
            data=[
                {
                    # data to create a tipohabitacion record
                    'descripcion': 'bgcigfahea',
                },
                {
                    # data to create a tipohabitacion record
                    'descripcion': 'bcejgaggif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.tipohabitacionWhereUniqueInput,
        include: Optional[types.tipohabitacionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single tipohabitacion record.

        Parameters
        ----------
        where
            tipohabitacion filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned tipohabitacion model

        Returns
        -------
        prisma.models.tipohabitacion
            The deleted tipohabitacion record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tipohabitacion = await tipohabitacion.prisma().delete(
            where={
                'id': 835903122,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.tipohabitacionWhereUniqueInput,
        include: Optional[types.tipohabitacionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique tipohabitacion record.

        Parameters
        ----------
        where
            tipohabitacion filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned tipohabitacion model

        Returns
        -------
        prisma.models.tipohabitacion
            The found tipohabitacion record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tipohabitacion = await tipohabitacion.prisma().find_unique(
            where={
                'id': 763719779,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.tipohabitacionWhereUniqueInput,
        include: Optional[types.tipohabitacionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique tipohabitacion record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            tipohabitacion filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned tipohabitacion model

        Returns
        -------
        prisma.models.tipohabitacion
            The found tipohabitacion record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tipohabitacion = await tipohabitacion.prisma().find_unique_or_raise(
            where={
                'id': 429995104,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.tipohabitacionWhereInput] = None,
        cursor: Optional[types.tipohabitacionWhereUniqueInput] = None,
        include: Optional[types.tipohabitacionInclude] = None,
        order: Optional[Union[types.tipohabitacionOrderByInput, List[types.tipohabitacionOrderByInput]]] = None,
        distinct: Optional[List[types.tipohabitacionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple tipohabitacion records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of tipohabitacion records returned
        skip
            Ignore the first N results
        where
            tipohabitacion filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned tipohabitacion model
        order
            Order the returned tipohabitacion records by any field
        distinct
            Filter tipohabitacion records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.tipohabitacion]
            The list of all tipohabitacion records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 tipohabitacion records
        tipohabitacions = await tipohabitacion.prisma().find_many(take=10)

        # find the first 5 tipohabitacion records ordered by the descripcion field
        tipohabitacions = await tipohabitacion.prisma().find_many(
            take=5,
            order={
                'descripcion': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.tipohabitacionWhereInput] = None,
        cursor: Optional[types.tipohabitacionWhereUniqueInput] = None,
        include: Optional[types.tipohabitacionInclude] = None,
        order: Optional[Union[types.tipohabitacionOrderByInput, List[types.tipohabitacionOrderByInput]]] = None,
        distinct: Optional[List[types.tipohabitacionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single tipohabitacion record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            tipohabitacion filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned tipohabitacion model
        order
            Order the returned tipohabitacion records by any field
        distinct
            Filter tipohabitacion records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.tipohabitacion
            The first tipohabitacion record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second tipohabitacion record ordered by the id field
        tipohabitacion = await tipohabitacion.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.tipohabitacionWhereInput] = None,
        cursor: Optional[types.tipohabitacionWhereUniqueInput] = None,
        include: Optional[types.tipohabitacionInclude] = None,
        order: Optional[Union[types.tipohabitacionOrderByInput, List[types.tipohabitacionOrderByInput]]] = None,
        distinct: Optional[List[types.tipohabitacionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single tipohabitacion record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            tipohabitacion filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned tipohabitacion model
        order
            Order the returned tipohabitacion records by any field
        distinct
            Filter tipohabitacion records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.tipohabitacion
            The first tipohabitacion record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second tipohabitacion record ordered by the tipo field
        tipohabitacion = await tipohabitacion.prisma().find_first_or_raise(
            skip=1,
            order={
                'tipo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.tipohabitacionUpdateInput,
        where: types.tipohabitacionWhereUniqueInput,
        include: Optional[types.tipohabitacionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single tipohabitacion record.

        Parameters
        ----------
        data
            tipohabitacion record data specifying what to update
        where
            tipohabitacion filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned tipohabitacion model

        Returns
        -------
        prisma.models.tipohabitacion
            The updated tipohabitacion record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tipohabitacion = await tipohabitacion.prisma().update(
            where={
                'id': 1775811865,
            },
            data={
                # data to update the tipohabitacion record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.tipohabitacionWhereUniqueInput,
        data: types.tipohabitacionUpsertInput,
        include: Optional[types.tipohabitacionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            tipohabitacion filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned tipohabitacion model

        Returns
        -------
        prisma.models.tipohabitacion
            The created or updated tipohabitacion record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tipohabitacion = await tipohabitacion.prisma().upsert(
            where={
                'id': 893145566,
            },
            data={
                'create': {
                    'id': 893145566,
                    'descripcion': 'bcejgaggif',
                },
                'update': {
                    'descripcion': 'bcejgaggif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.tipohabitacionUpdateManyMutationInput,
        where: types.tipohabitacionWhereInput,
    ) -> int:
        """Update multiple tipohabitacion records

        Parameters
        ----------
        data
            tipohabitacion data to update the selected tipohabitacion records to
        where
            Filter to select the tipohabitacion records to update

        Returns
        -------
        int
            The total number of tipohabitacion records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all tipohabitacion records
        total = await tipohabitacion.prisma().update_many(
            data={
                'descripcion': 'jjfeafhfj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.tipohabitacionWhereInput] = None,
        cursor: Optional[types.tipohabitacionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of tipohabitacion records present in the database

        Parameters
        ----------
        select
            Select the tipohabitacion fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            tipohabitacion filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.tipohabitacionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await tipohabitacion.prisma().count()

        # results: prisma.types.tipohabitacionCountAggregateOutput
        results = await tipohabitacion.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.tipohabitacionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.tipohabitacionWhereInput] = None,
        cursor: Optional[types.tipohabitacionWhereUniqueInput] = None,
    ) -> types.tipohabitacionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.tipohabitacionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.tipohabitacionWhereInput] = None,
        cursor: Optional[types.tipohabitacionWhereUniqueInput] = None,
    ) -> Union[int, types.tipohabitacionCountAggregateOutput]:
        """Count the number of tipohabitacion records present in the database

        Parameters
        ----------
        select
            Select the tipohabitacion fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            tipohabitacion filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.tipohabitacionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await tipohabitacion.prisma().count()

        # results: prisma.types.tipohabitacionCountAggregateOutput
        results = await tipohabitacion.prisma().count(
            select={
                '_all': True,
                'tipo': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.tipohabitacionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.tipohabitacionWhereInput] = None
    ) -> int:
        """Delete multiple tipohabitacion records.

        Parameters
        ----------
        where
            Optional tipohabitacion filter to find the records to be deleted

        Returns
        -------
        int
            The total number of tipohabitacion records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all tipohabitacion records
        total = await tipohabitacion.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.tipohabitacionScalarFieldKeys'],
        *,
        where: Optional['types.tipohabitacionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.tipohabitacionAvgAggregateInput'] = None,
        sum: Optional['types.tipohabitacionSumAggregateInput'] = None,
        min: Optional['types.tipohabitacionMinAggregateInput'] = None,
        max: Optional['types.tipohabitacionMaxAggregateInput'] = None,
        having: Optional['types.tipohabitacionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.tipohabitacionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.tipohabitacionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.tipohabitacionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.tipohabitacionGroupByOutput']:
        """Group tipohabitacion records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar tipohabitacion fields to group records by
        where
            tipohabitacion filter to select records
        take
            Limit the maximum number of tipohabitacion records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.tipohabitacionGroupByOutput]
            A list of dictionaries representing the tipohabitacion record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group tipohabitacion records by descripcion values
        # and count how many records are in each group
        results = await tipohabitacion.prisma().group_by(
            ['descripcion'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class habitacionesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.habitaciones]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await habitaciones.prisma().query_raw(
            'SELECT * FROM habitaciones WHERE id = ?',
            2102736524,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.habitaciones
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await habitaciones.prisma().query_first(
            'SELECT * FROM habitaciones WHERE numero = ?',
            'chbfcacbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.habitacionesCreateInput,
        include: Optional[types.habitacionesInclude] = None
    ) -> _PrismaModelT:
        """Create a new habitaciones record.

        Parameters
        ----------
        data
            habitaciones record data
        include
            Specifies which relations should be loaded on the returned habitaciones model

        Returns
        -------
        prisma.models.habitaciones
            The created habitaciones record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a habitaciones record from just the required fields
        habitaciones = await habitaciones.prisma().create(
            data={
                # data to create a habitaciones record
                'numero': 'efggddide',
                'tipohabitacionId': 2058258651,
                'costo': 'bfidgijfjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.habitacionesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple habitaciones records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of habitaciones record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await habitaciones.prisma().create_many(
            data=[
                {
                    # data to create a habitaciones record
                    'numero': 'ihieecagf',
                    'tipohabitacionId': 1675280054,
                    'costo': 'bgchfhgceh',
                },
                {
                    # data to create a habitaciones record
                    'numero': 'cafeiaccbc',
                    'tipohabitacionId': 60335757,
                    'costo': 'gieegcbeg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.habitacionesWhereUniqueInput,
        include: Optional[types.habitacionesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single habitaciones record.

        Parameters
        ----------
        where
            habitaciones filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned habitaciones model

        Returns
        -------
        prisma.models.habitaciones
            The deleted habitaciones record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        habitaciones = await habitaciones.prisma().delete(
            where={
                'id': 1625503827,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.habitacionesWhereUniqueInput,
        include: Optional[types.habitacionesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique habitaciones record.

        Parameters
        ----------
        where
            habitaciones filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned habitaciones model

        Returns
        -------
        prisma.models.habitaciones
            The found habitaciones record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        habitaciones = await habitaciones.prisma().find_unique(
            where={
                'id': 521827728,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.habitacionesWhereUniqueInput,
        include: Optional[types.habitacionesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique habitaciones record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            habitaciones filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned habitaciones model

        Returns
        -------
        prisma.models.habitaciones
            The found habitaciones record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        habitaciones = await habitaciones.prisma().find_unique_or_raise(
            where={
                'id': 1266032265,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.habitacionesWhereInput] = None,
        cursor: Optional[types.habitacionesWhereUniqueInput] = None,
        include: Optional[types.habitacionesInclude] = None,
        order: Optional[Union[types.habitacionesOrderByInput, List[types.habitacionesOrderByInput]]] = None,
        distinct: Optional[List[types.habitacionesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple habitaciones records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of habitaciones records returned
        skip
            Ignore the first N results
        where
            habitaciones filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned habitaciones model
        order
            Order the returned habitaciones records by any field
        distinct
            Filter habitaciones records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.habitaciones]
            The list of all habitaciones records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 habitaciones records
        habitaciones = await habitaciones.prisma().find_many(take=10)

        # find the first 5 habitaciones records ordered by the tipohabitacionId field
        habitaciones = await habitaciones.prisma().find_many(
            take=5,
            order={
                'tipohabitacionId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.habitacionesWhereInput] = None,
        cursor: Optional[types.habitacionesWhereUniqueInput] = None,
        include: Optional[types.habitacionesInclude] = None,
        order: Optional[Union[types.habitacionesOrderByInput, List[types.habitacionesOrderByInput]]] = None,
        distinct: Optional[List[types.habitacionesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single habitaciones record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            habitaciones filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned habitaciones model
        order
            Order the returned habitaciones records by any field
        distinct
            Filter habitaciones records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.habitaciones
            The first habitaciones record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second habitaciones record ordered by the costo field
        habitaciones = await habitaciones.prisma().find_first(
            skip=1,
            order={
                'costo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.habitacionesWhereInput] = None,
        cursor: Optional[types.habitacionesWhereUniqueInput] = None,
        include: Optional[types.habitacionesInclude] = None,
        order: Optional[Union[types.habitacionesOrderByInput, List[types.habitacionesOrderByInput]]] = None,
        distinct: Optional[List[types.habitacionesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single habitaciones record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            habitaciones filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned habitaciones model
        order
            Order the returned habitaciones records by any field
        distinct
            Filter habitaciones records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.habitaciones
            The first habitaciones record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second habitaciones record ordered by the id field
        habitaciones = await habitaciones.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.habitacionesUpdateInput,
        where: types.habitacionesWhereUniqueInput,
        include: Optional[types.habitacionesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single habitaciones record.

        Parameters
        ----------
        data
            habitaciones record data specifying what to update
        where
            habitaciones filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned habitaciones model

        Returns
        -------
        prisma.models.habitaciones
            The updated habitaciones record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        habitaciones = await habitaciones.prisma().update(
            where={
                'id': 93253262,
            },
            data={
                # data to update the habitaciones record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.habitacionesWhereUniqueInput,
        data: types.habitacionesUpsertInput,
        include: Optional[types.habitacionesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            habitaciones filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned habitaciones model

        Returns
        -------
        prisma.models.habitaciones
            The created or updated habitaciones record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        habitaciones = await habitaciones.prisma().upsert(
            where={
                'id': 2053047983,
            },
            data={
                'create': {
                    'id': 2053047983,
                    'numero': 'cafeiaccbc',
                    'tipohabitacionId': 60335757,
                    'costo': 'gieegcbeg',
                },
                'update': {
                    'numero': 'cafeiaccbc',
                    'tipohabitacionId': 60335757,
                    'costo': 'gieegcbeg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.habitacionesUpdateManyMutationInput,
        where: types.habitacionesWhereInput,
    ) -> int:
        """Update multiple habitaciones records

        Parameters
        ----------
        data
            habitaciones data to update the selected habitaciones records to
        where
            Filter to select the habitaciones records to update

        Returns
        -------
        int
            The total number of habitaciones records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all habitaciones records
        total = await habitaciones.prisma().update_many(
            data={
                'numero': 'gifdddbia'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.habitacionesWhereInput] = None,
        cursor: Optional[types.habitacionesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of habitaciones records present in the database

        Parameters
        ----------
        select
            Select the habitaciones fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            habitaciones filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.habitacionesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await habitaciones.prisma().count()

        # results: prisma.types.habitacionesCountAggregateOutput
        results = await habitaciones.prisma().count(
            select={
                '_all': True,
                'tipohabitacionId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.habitacionesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.habitacionesWhereInput] = None,
        cursor: Optional[types.habitacionesWhereUniqueInput] = None,
    ) -> types.habitacionesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.habitacionesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.habitacionesWhereInput] = None,
        cursor: Optional[types.habitacionesWhereUniqueInput] = None,
    ) -> Union[int, types.habitacionesCountAggregateOutput]:
        """Count the number of habitaciones records present in the database

        Parameters
        ----------
        select
            Select the habitaciones fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            habitaciones filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.habitacionesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await habitaciones.prisma().count()

        # results: prisma.types.habitacionesCountAggregateOutput
        results = await habitaciones.prisma().count(
            select={
                '_all': True,
                'costo': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.habitacionesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.habitacionesWhereInput] = None
    ) -> int:
        """Delete multiple habitaciones records.

        Parameters
        ----------
        where
            Optional habitaciones filter to find the records to be deleted

        Returns
        -------
        int
            The total number of habitaciones records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all habitaciones records
        total = await habitaciones.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.habitacionesScalarFieldKeys'],
        *,
        where: Optional['types.habitacionesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.habitacionesAvgAggregateInput'] = None,
        sum: Optional['types.habitacionesSumAggregateInput'] = None,
        min: Optional['types.habitacionesMinAggregateInput'] = None,
        max: Optional['types.habitacionesMaxAggregateInput'] = None,
        having: Optional['types.habitacionesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.habitacionesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.habitacionesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.habitacionesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.habitacionesGroupByOutput']:
        """Group habitaciones records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar habitaciones fields to group records by
        where
            habitaciones filter to select records
        take
            Limit the maximum number of habitaciones records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.habitacionesGroupByOutput]
            A list of dictionaries representing the habitaciones record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group habitaciones records by id values
        # and count how many records are in each group
        results = await habitaciones.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models